# -*- coding: utf-8 -*-
"""Environmental_clustering.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VphYVieqOBZJt5o-znV1vkQURL7uKUk9

#Climate and Environmental Data Clustering and Forecasting:

This project performs an in-depth analysis of climate and environmental data across multiple countries. The goal is to identify patterns among countries using clustering and to forecast key environmental metrics with regression. We use a dataset of climate indicators (such as temperature, CO₂ emissions, and rainfall) for many countries over several years.
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from google.colab import files
uploaded=files.upload()

df=pd.read_csv("update_temperature[1].csv")
df.head()
df

print("null_values:", df.isnull().sum())
print("dupliacted_values:", df.duplicated().sum())
print("total unique country:",df['Country'].nunique())
print("total unique year:",df['Year'].nunique())
print("rows and columns:", df.shape)

for column in df.select_dtypes(include="number").columns:
  Q3=df[column].quantile(0.75)
  Q1=df[column].quantile(0.25)          ### outlier handling
  IQR=Q3-Q1
  lower_limit=Q1-1.5*IQR
  upper_limit=Q3+1.5*IQR
df[column] = df[column].clip(lower_limit, upper_limit)
df.shape

sns.boxplot(data=df, x="Rainfall_mm")
plt.show()

for column in df.select_dtypes(include="number").columns:
  print(df[column].name)
  print(df[column].skew())

"""## Correlation matrix:"""

corr=df[["Rainfall_mm", "Forest_Area_pct", "Population", "Extreme_Weather_Events",
         "Renewable_Energy_pct", "Sea_Level_Rise_mm", "CO2_Emissions_tons_per_capita", "Avg_Temperature_degC"]].corr()
corr

"""#Relation	Correlation	Meaning
Population ↔ Extreme Events	0.58	More people → more events recorded

Rainfall ↔ Forest	0.51	Forests increase precipitation

Extreme Events ↔ Sea Level	0.60	Coastal countries affected more

Rainfall ↔ Renewable Energy	0.41	Hydropower dominant countries

CO₂ ↔ Rainfall	–0.56	High-CO₂ nations are mostly dry climates
"""

corr=df[["Rainfall_mm", "Forest_Area_pct", "Population", "Extreme_Weather_Events", "Renewable_Energy_pct",
         "CO2_Emissions_tons_per_capita", "Sea_Level_Rise_mm"]].corr()
sns.heatmap(corr, annot=True, cmap="coolwarm")
plt.xticks(rotation=90)
plt.show()

"""The dataset contains annual measurements of environmental variables for each country. Key features include average temperature, total CO₂ emissions, and total annual rainfall, among others. Each record corresponds to a country–year pair. This multi-year, multi-country dataset allows us to analyze global trends and compare countries on the same metrics."""

df.describe()

"""### Countrywise average temprature: Top 5 highest  """

top_5_countries_temp=df.groupby(["Country"])["Avg_Temperature_degC"].mean().sort_values(ascending=False)[:5]
print(top_5_countries_temp)

### Nigeria has the highest average temperature.

# Get the names of the top 5 countries from group by top_5_countries_temp
top_country_names = top_5_countries_temp.index

# Filter the original DataFrame to include only these top 5 countries
df_top_5 = df[df['Country'].isin(top_country_names)]

# Now plot using this filtered DataFrame
sns.lineplot(x='Year', y='Avg_Temperature_degC', hue='Country', data=df_top_5)
plt.legend(title="Country",  bbox_to_anchor=(1.05,1), loc="upper left")
plt.show()

"""### Countrywise CO2 emissions: Top 5 CO2 emitting country"""

top_5_countries_co2=df.groupby(["Country"])["CO2_Emissions_tons_per_capita"].mean().sort_values(ascending=False)[:5]
print(top_5_countries_co2)

top_cname=top_5_countries_co2.index

df_top_co2=df[df["Country"].isin(top_cname)]
df_top_co2

###### Saudi Arabia has highest CO2 emissions in tons per capita

sns.lineplot(x=df_top_co2["Year"], y=df_top_co2["CO2_Emissions_tons_per_capita"], hue=df_top_co2["Country"])
plt.legend(title="Country", bbox_to_anchor=(1.05, 1), loc="upper left")
plt.show()

"""### Countrywise rainfall:"""

top5_rainfall=df.groupby("Country")["Rainfall_mm"].mean().sort_values(ascending=False)[:5]
print(top5_rainfall)

top5_rainfall_names=top5_rainfall.index
print(top5_rainfall_names)

df_rainfall=df[df["Country"].isin(top5_rainfall_names)]
df_rainfall                                                       ### Indonesia has highest rainfall.


sns.scatterplot(x=df_rainfall["Year"], y=df_rainfall["Rainfall_mm"], hue=df_rainfall["Country"])
plt.legend(title="Country", bbox_to_anchor=(1.05, 1), loc="upper left")
plt.show()

"""### Top 5 countries with highest forest area percentage"""

top5_forest=df.groupby("Country")["Forest_Area_pct"].mean().sort_values(ascending=False)[:5]

top_names=top5_forest.index

df_forest=df[df["Country"].isin(top_names)]   ### brazil has highest forest areal percentage.

sns.scatterplot(x=df_forest["Year"], y=df_forest["Forest_Area_pct"], hue=df_forest["Country"])
plt.legend(title="Country", bbox_to_anchor=(1.05, 1), loc="upper left")
plt.show()

"""## Top5 countries which has most of the extreme weather events:  """

df.head(1)
top5_Extreme=df.groupby("Country")["Extreme_Weather_Events"].mean().sort_values(ascending=False)[:5]
top5_Extreme

top5_extreme_names=top5_Extreme.index
df_extreme=df[df["Country"].isin(top5_extreme_names)]     ### united states has most of the extreme weather events.

sns.lineplot(data=df_extreme, x="Year", y="Extreme_Weather_Events", hue="Country")
plt.show()

"""Data Exploration

Before applying clustering, we explore the data to understand each variable’s behavior:

CO₂ Emissions: We examine the distribution and trends in CO₂ emissions by country. Typically, the plots show that a few countries have very high emissions (industrialized nations), while many countries have lower emissions. Over time, global CO₂ tends to increase.

Temperature: We look at average temperatures across countries. The data often shows a gradual rise in global average temperature, reflecting climate warming, with regional variations across countries.

Rainfall: We visualize annual rainfall totals. This highlights how precipitation varies by region; some countries have consistently high rainfall, while others (such as desert regions) have very low values.



These plots help us see broad differences between countries and global trends. For example, time-series plots might reveal that countries with growing industries are increasing their emissions more sharply than others. These initial insights guide the clustering and modeling steps of the analysis.

#Clustering:

We want to group countries that have similar environmental profiles, so we apply K-means clustering (a common unsupervised learning algorithm). We select relevant features from the dataset (for example: average temperature, CO₂ emissions, and rainfall). Because these features are on different scales (CO₂ is in metric tons, rainfall in millimeters, etc.), we scale (standardize) them. Scaling ensures that each variable contributes equally to the distance calculations in the clustering algorithm.
"""

# Group by each country and take MEAN of all numeric climate features
df_country = df.groupby("Country").mean(numeric_only=True)

# Drop Year (not meaningful in clustering)
df_country = df_country.drop(columns=["Year"])


# features
x = df_country.copy()

## feature scaling
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import *

scaler = StandardScaler()
x_scaled = scaler.fit_transform(x)


from sklearn.cluster import KMeans
for k in range(2,6):
    km = KMeans(n_clusters=k, random_state=0)
    labels = km.fit_predict(x_scaled)
    print(k, silhouette_score(x_scaled, labels))

# K-means clustering
kmeans = KMeans(n_clusters=4, random_state=0)
df_country["Cluster"] = kmeans.fit_predict(x_scaled)

print(df_country["Cluster"])

score = silhouette_score(x_scaled, df_country["Cluster"])
print("Silhouette Score:", score)

# Now create cluster profile
cluster_profile = df_country.groupby("Cluster").mean()
cluster_profile

"""PCA and t-SNE Visualizations

To visualize the high-dimensional data, we apply dimension reduction:

Principal Component Analysis (PCA): PCA projects the data into a lower-dimensional space by finding the directions (principal components) of greatest variance. By plotting the first two principal components, we can see how countries spread out in the data and how clusters separate in a 2D plot.

t-SNE (t-distributed Stochastic Neighbor Embedding): t-SNE is another technique to reduce dimensions, designed to preserve local similarities between points. A t-SNE plot of the data often reveals cluster structure more clearly than PCA when the true structure is complex.

We then plot each country in the reduced PCA and t-SNE spaces with colors indicating their cluster membership. These scatter plots help confirm the structure of the clusters identified by K-means.
"""

from sklearn.decomposition import PCA
pca=PCA(n_components=2, random_state=0)
pca_result=pca.fit_transform(x_scaled)

df_country["PCA1"]=pca_result[:,0]
df_country["PCA2"]=pca_result[:,1]

# print("PCA1:", df_country["PCA1"])
# print("PCA2:", df_country["PCA2"])



plt.figure(figsize=(9,5))
sns.scatterplot(data=df_country, x="PCA1", y="PCA2", hue="Cluster", palette="tab10", s=80)
plt.title("PCA for cluster visualization")
plt.show()

"""PCA and t-SNE show different cluster shapes because they use completely different dimensionality reduction methods. PCA preserves global structure but distorts local neighborhoods, while t-SNE preserves local neighborhoods but distorts global distances. Therefore, their 2D visualizations will never match each other or the true K-Means cluster structure exactly."""

#t-SNE (2D Visualization of clusters)

from sklearn.manifold import TSNE

tsne = TSNE(n_components=2, perplexity=10, random_state=0)
tsne_result = tsne.fit_transform(x_scaled)

df_country["TSNE1"] = tsne_result[:, 0]
df_country["TSNE2"] = tsne_result[:, 1]

# print("TSNE1:", df_country["TSNE1"])
# print("TSNE2:", df_country["TSNE2"])



plt.figure(figsize=(8,5))
sns.scatterplot(data=df_country,x="TSNE1",y="TSNE2", hue="Cluster", palette="tab10", s=90)
plt.title("t-SNE Visualization of Climate Clusters")
plt.legend(title="Cluster")
plt.show()

cluster_profile = df_country.groupby("Cluster").mean()
cluster_profile

cluster_summary = df_country.groupby("Cluster").mean()[[
    "Avg_Temperature_degC",
    "CO2_Emissions_tons_per_capita",
    "Rainfall_mm",
    "Forest_Area_pct",
    "Population"
]]
cluster_summary

print(df_country[["Cluster"]].sort_values("Cluster"))

cluster_summary = df_country.groupby("Cluster").mean()
cluster_summary

df.head(1)

df_with_cluster = pd.merge(df, df_country["Cluster"], on="Country")
df_with_cluster.head()

"""### CO2 Emissions prediction using LinearRegression:

We also model trends in environmental metrics over time. As a simple forecasting task, we fit a linear regression of CO₂ emissions versus year for each country (treating year as the predictor and emissions as the response). The resulting model provides a basic projection of future emissions, assuming the past trend continues linearly. We evaluate each model (e.g., using R² or mean squared error) to see how well it fits the historical data.

Examining the regression results allows us to compare trends between countries. For example, a country with a high positive slope in its CO₂ regression is increasing emissions rapidly, whereas a flatter trend indicates more stable emissions.
"""

from sklearn.linear_model import LinearRegression

# Future years to predict
future_years = [[2025], [2030], [2035]]

# List of all countries
countries = df_with_cluster["Country"].unique()

for country_name in countries:

    # Filter dataset for this country
    country_data = df_with_cluster[df_with_cluster["Country"] == country_name]

    # X = Year, y = CO2
    X = country_data[["Year"]]   # Must be 2D
    y = country_data["CO2_Emissions_tons_per_capita"]

    # Build the model
    model = LinearRegression()
    model.fit(X, y)

    # Predict future CO₂ values
    predicted_values = model.predict(future_years)

    # Print results
    print(f"\nCountry: {country_name}")
    print("2025:", round(predicted_values[0], 3))
    print("2030:", round(predicted_values[1], 3))
    print("2035:", round(predicted_values[2], 3))

"""Linear Regression normally uses train_test_split to divide data into training and testing parts.
But time-series data (like years 2000–2024) is different because the order of time matters.Time-series must stay in correct order (past → present → future).Train_test_split shuffles the data and mixes years randomly.

Conclusion

Through clustering, we identified groups of countries with similar climate profiles. Industrialized nations tended to cluster together due to high emissions and temperatures, while less-developed countries formed a separate cluster with lower values. The forecasting exercise highlighted which countries have rapidly increasing emissions and which are relatively stable.
"""

